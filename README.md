# jdavredbeard-homelab  

Context:

At my previous job I wrote a tool I named `paraterra` to allow for parallel Terraform operations across accounts, in a manner similar to CloudFormation StackSets. The paraterra repo included a Python CLI and GitHub Actions workflows that called both paraterra and terraform CLI's. The paraterra CLI could select arbitrary groups of AWS accounts associated with a repo based on config values (for example, from tfvars.json files, or from AWS SSM parameters which paraterra resolved using boto3), and the GHA workflow would run terraform plans or applies inparallel containers in a Matrix strategy over the list of accounts. This functionality allowed us to create pipelines with progressive deployments by environment group (i.e. user teams generally had `dev`, `staging`, and `prod` accounts, so we could deploy platform infra to all user `dev` environments, then all user `staging` environments, and etc). 

The GHA workflows uploaded the json outputs of these commands as GHA artifacts, and then after the matrix job, downloaded the json files and aggregated the counts of changes and displayed a table of the numbers of resource creates, updates, and destroys per account. This table allowed us to have a low resolution view into the `terraform plan` output across accounts, making outlier plans obvious. As each terraform command per account ran in its own build container, it was easy to drill down into each account run to see the details of the plan.

Project:

Write an MVP of `paralumi` in Go - the pulumi version of paraterra. Instead of using GitHub Actions to run the parallel previews/ups, use the automation api with goroutines. Use config values to select groups of Environments, and use OIDC in Environments to handle authentication with AWS.

How it went:

First I defined a Typescript Pulumi stack of Environments. Since I only have access to a couple AWS accounts at Pulumi, I made all the Environments point at the same account. I added two config values for potential grouping - `animal`, which might stand in for a more realistic usage like `app` or `team` - and `group`, which holds environment level values (dev, staging, prod). This way, you can select either all environments of a certain level (`group:dev`), or all environments of a certain animal\team (`animal:wombat`). As far as the pulumi code goes, this was very easy and fast to write, especially as it made sense to use loops to define the Environments, and the `fs` module to read the base yaml from a file.

One thing I notice here is that the `yaml` property of the Environment resource is considered a secret (which probably makes sense since it would often contain credentials) - but since the Environment resource is resolving dynamic credentials, running `pulumi refresh --preview-only` shows drift on the `yaml` property whenever you run it - but you can't see what the drift is. This is unfortunate if the drift you are looking for is a config value that is not a secret - I wonder if there is a more granular way to define this property?

The bulk of the work was in reading and understanding the Automation API code enough to write the CLI. I quickly ran into the issue that not all pulumi commands are represented in the package, and not all flags are available for the commands that are represented. I was able to write my own functions to call pulumi commands based on examples in local_workspace.go (see listEnvironmentsForOrg and getConfigValue in paralumi) - however, I wonder if it would make sense to make `runPulumiCmdSync` public rather than private, as I ended up writing my own version of it in order to avoid passing all those `nil` values every time to `PulumiCommand.Run()`. If it is intentional to not represent all pulumi commands in the auto api, It might be nice for the documentation to explain why, and to show how to write functions to add commands yourself. For functions like Preview that are represented, the flag I was hoping for was `--json` to get the full preview details - the ChangeSummary struct ended up being enough for the MVP though, as it already contained a count of the change types that I wanted for the table.

Overall I was satisfied with what I was able to do - paralumi searches a passed org for all environments that contain a passed config key:value, checks the workspace for existing stacks that reference that environment, creates new stacks for environments that are not already referenced, runs previews and ups in goroutines against the combined list of stacks, streams individual stdouts to files in the local filesystem for inspection if desired, aggregates the changes via a channel, and prints a table of the changes by stack/env. I'm happy that I was able to write this without all the yaml of GitHub Actions. 

